#!/usr/bin/env python3
# Only extend FIRST ribs (L/R) and write one file per rib to:
#   postprocessed_output/before_smoothing/<subj>_<ribfile>_postprocessed.nii.gz
#   postprocessed_output/refined/<subj>_<ribfile>_postprocessed.nii.gz
#
# Layout preserved:
#   base_dir/TotalSegmentator_Data/CFxxxx/
#       CFxxxx_resampled.nii.gz
#       CFxxxx_test/  (contains rib_left_1.nii.gz, rib_right_1.nii.gz, etc.)
#
# No sternum needed. Growth is HU-gated, corridor-limited, and spine-excluded.

import os
import re
import numpy as np
import SimpleITK as sitk
from scipy.ndimage import convolve

# -------------------- knobs (tuned for longer, thicker, spine-safe tips) --------------------
UPPER_HU = 1200.0

# classify anterior tips vs posterior (avoid spine-side endpoints)
NBHD_RADIUS_MM       = 9.0      # small ball around endpoint to inspect neighbors
NBHD_BONE_HU         = 600.0    # HU counted as "other dense bone" (vertebrae, joints)
NBHD_BONE_FRAC_MAX   = 0.05     # max fraction of such bone allowed near endpoint

# Tier A (cortical growth): long reach, strict HU to avoid spine
A_LOWER_FLOOR        = 460.0    # keep hard-bone safe; raise if any spine creep
A_PCTL               = 40       # percentile of in-rib HU (lower bound = max(A_PCTL, A_LOWER_FLOOR))
A_R_RIB_MM           = 0.0     # distance band from rib surface (distance map, mm)
A_R_TIP_MM           = 0.0     # sphere around endpoint (mm)

# Tier B (cartilage rounding): short range, permissive HU for tip rounding
B_LOWER_FLOOR        = 180.0
B_PCTL               = 25
B_R_RIB_MM           = 12.0
B_R_TIP_MM           = 16.0

# Auto spine exclusion (mask vertebrae) + extra corridor clearance
SPINE_HU             = 480.0
SPINE_MID_TOL_MM     = 20.0     # how close to midline (x) to consider as spine
SPINE_Z_EXT_MM       = 60.0     # min z-extent at high HU to accept as spine
SPINE_CLEAR_MM       = 8.0      # NEW: corridor must be >= this far from spine

# Tiny smoothing on repaired rib only
FINAL_CLOSING        = (8, 0, 8)  # voxel radii (x,y,z)

# Add gentle thickness to grown tip inside corridor + HU gate only
POST_THICKEN_MM      = 0

# -------------------- helpers --------------------
def read_img(p): return sitk.ReadImage(p)
def write_img(img, p):
    os.makedirs(os.path.dirname(p), exist_ok=True)
    sitk.WriteImage(img, p)

def to_u8(img): return sitk.Cast(img>0, sitk.sitkUInt8)
def to_f32(img): return sitk.Cast(img, sitk.sitkFloat32)
def arr(img): return sitk.GetArrayFromImage(img)

def resample_like(moving, fixed, interp=sitk.sitkNearestNeighbor):
    R = sitk.ResampleImageFilter()
    R.SetReferenceImage(fixed)
    R.SetInterpolator(interp)
    R.SetTransform(sitk.Transform())
    R.SetDefaultPixelValue(0)
    return R.Execute(moving)

def dist_map_mm(bin_u8):
    return sitk.SignedMaurerDistanceMap(bin_u8, insideIsPositive=False,
                                        squaredDistance=False, useImageSpacing=True)

def skeleton(bin_u8): return sitk.BinaryThinning(bin_u8)

def endpoints_from_skeleton(skel_u8):
    """Return endpoints as physical points."""
    sk = arr(skel_u8).astype(np.uint8)           # (z,y,x)
    nb = convolve(sk, np.ones((3,3,3), dtype=np.uint8), mode="constant", cval=0)
    ep = (sk == 1) & (nb == 2)                   # voxel + exactly one neighbor
    zyx = np.argwhere(ep)
    to_phys = lambda z,y,x: skel_u8.TransformIndexToPhysicalPoint((int(x), int(y), int(z)))
    return [to_phys(*p) for p in zyx]

def stats_percentiles_in_mask(ct, mask_u8, pcts=(20, 40)):
    m = arr(mask_u8)>0
    hu = arr(ct)[m]
    if hu.size == 0:
        return [300.0 for _ in pcts]
    return [float(np.percentile(hu, p)) for p in pcts]

def build_spine_mask(ct):
    """Detect spine: high-HU components near midline with large z-extent."""
    sp = ct.GetSpacing(); origin = ct.GetOrigin(); size = ct.GetSize()
    mid_x_phys = origin[0] + sp[0]*(size[0]/2.0)
    high = to_u8(ct >= SPINE_HU)
    if not arr(high).any():
        out = sitk.Image(ct.GetSize(), sitk.sitkUInt8); out.CopyInformation(ct); return out
    cc = sitk.ConnectedComponent(high)
    ls = sitk.LabelShapeStatisticsImageFilter(); ls.Execute(cc)
    out = sitk.Image(ct.GetSize(), sitk.sitkUInt8); out.CopyInformation(ct)
    for L in ls.GetLabels():
        cx, cy, cz = ls.GetCentroid(L)
        x,y,z,sx,sy,sz = ls.GetBoundingBox(L)
        z_extent_mm = sz*sp[2]
        if abs(cx - mid_x_phys) <= SPINE_MID_TOL_MM and z_extent_mm >= SPINE_Z_EXT_MM:
            out = sitk.Or(out, to_u8(sitk.BinaryThreshold(cc, L, L, 1, 0)))
    # a hair of dilation to be conservative
    return sitk.BinaryDilate(out, (1,1,1)) if arr(out).any() else out

def endpoint_is_anterior(ct, ribs_u8, ep_phys, nbhd_mm, bone_hu, frac_max):
    """Accept endpoint if neighborhood has limited other-dense-bone (not rib)."""
    idx = ct.TransformPhysicalPointToIndex(ep_phys)
    sp = ct.GetSpacing()
    rx = max(1, int(round(nbhd_mm/sp[0])))
    ry = max(1, int(round(nbhd_mm/sp[1])))
    rz = max(1, int(round(nbhd_mm/sp[2])))
    X,Y,Z = ct.GetSize()
    x0,x1 = max(0, idx[0]-rx), min(X-1, idx[0]+rx)
    y0,y1 = max(0, idx[1]-ry), min(Y-1, idx[1]+ry)
    z0,z1 = max(0, idx[2]-rz), min(Z-1, idx[2]+rz)
    ct_a  = arr(ct); rib_a = arr(ribs_u8)
    roi_ct  = ct_a[z0:z1+1, y0:y1+1, x0:x1+1]
    roi_rib = rib_a[z0:z1+1, y0:y1+1, x0:x1+1]
    other_bone = (roi_ct >= bone_hu) & (roi_rib == 0)
    return other_bone.mean() <= frac_max

def corridor_for_tip(ribs_u8, spine_u8, ep_phys, r_rib_mm, r_tip_mm, ct=None):
    """Corridor = near-rib band âˆ© endpoint sphere âˆ© spine-clearance."""
    d_rib = dist_map_mm(ribs_u8)
    near_rib = to_u8(d_rib <= r_rib_mm)

    center_idx = ribs_u8.TransformPhysicalPointToIndex(ep_phys)
    sphere = sitk.Image(ribs_u8.GetSize(), sitk.sitkUInt8); sphere.CopyInformation(ribs_u8)
    if all(0 <= i < s for i,s in zip(center_idx, ribs_u8.GetSize())):
        sphere[center_idx] = 1
    sp = ribs_u8.GetSpacing()
    rad = (max(1,int(round(r_tip_mm/sp[0]))),
           max(1,int(round(r_tip_mm/sp[1]))),
           max(1,int(round(r_tip_mm/sp[2]))))
    sphere = sitk.BinaryDilate(sphere, rad)

    cor = sitk.And(near_rib, sphere)

    if arr(spine_u8).any():
        # explicit spine clearance in mm using distance map
        d_spine = dist_map_mm(spine_u8)   # outside is positive
        spine_clear = to_u8(d_spine >= SPINE_CLEAR_MM)
        cor = sitk.And(cor, spine_clear)

    return cor

def region_grow_local(ct, seeds_phys, lo, hi, corridor_u8):
    """ConnectedThreshold inside corridor only."""
    if not seeds_phys:
        empty = sitk.Image(ct.GetSize(), sitk.sitkUInt8); empty.CopyInformation(ct); return empty
    # mask out everything outside the corridor (very low HU)
    ct_masked = sitk.Mask(ct, corridor_u8, outsideValue=-2000.0)
    seed_idx = [ct.TransformPhysicalPointToIndex(p) for p in seeds_phys]
    rg = sitk.ConnectedThreshold(ct_masked, seedList=seed_idx, lower=lo, upper=hi)
    return to_u8(rg)

def keep_growth_touching_rib(grow_u8, rib_u8):
    """Keep only grown components that touch the rib (1-voxel dilated)."""
    if not arr(grow_u8).any():
        return grow_u8
    rib_d = sitk.BinaryDilate(rib_u8, (1,1,1))
    cc = sitk.ConnectedComponent(grow_u8)
    ls = sitk.LabelShapeStatisticsImageFilter(); ls.Execute(cc)
    out = sitk.Image(grow_u8.GetSize(), sitk.sitkUInt8); out.CopyInformation(grow_u8)
    for L in ls.GetLabels():
        comp = to_u8(sitk.BinaryThreshold(cc, L, L, 1, 0))
        if arr(sitk.And(comp, rib_d)).any():
            out = sitk.Or(out, comp)
    return out

def thicken_growth_in_corridor(ct, growth_u8, corridor_u8, lower, upper):
    """Dilate grown tip slightly, but clamp to corridor and HU range."""
    if not arr(growth_u8).any():
        return growth_u8
    sp = ct.GetSpacing()
    rad = (max(1,int(round(POST_THICKEN_MM/sp[0]))),
           max(1,int(round(POST_THICKEN_MM/sp[1]))),
           max(0,int(round(POST_THICKEN_MM/sp[2]))))
    grown = sitk.BinaryDilate(growth_u8, rad)

    hu_ok = to_u8(sitk.And(ct >= lower, ct <= upper))
    thick = sitk.And(grown, sitk.And(corridor_u8, hu_ok))
    return thick

def repair_first_rib(ct, rib_path, out_path):
    # load rib and align to CT grid
    rib_raw = read_img(rib_path)
    rib = to_u8(resample_like(to_u8(rib_raw), ct))

    # adaptive HU bounds from this rib only
    p20, p40 = stats_percentiles_in_mask(ct, rib, (B_PCTL, A_PCTL))
    a_lower = max(p40, A_LOWER_FLOOR)
    b_lower = max(p20, B_LOWER_FLOOR)
    print(f"[INFO] {os.path.basename(rib_path)} â†’ Tier-A lower={a_lower:.1f}, Tier-B lower={b_lower:.1f}")

    spine = build_spine_mask(ct)

    # endpoints â†’ keep only anterior-like
    skel = skeleton(rib)
    endpoints = endpoints_from_skeleton(skel)
    ant_seeds = [ep for ep in endpoints
                 if endpoint_is_anterior(ct, rib, ep, NBHD_RADIUS_MM, NBHD_BONE_HU, NBHD_BONE_FRAC_MAX)]
    print(f"[INFO] {os.path.basename(rib_path)} â†’ endpoints: {len(endpoints)}, anterior-like: {len(ant_seeds)}")

    grow_union = sitk.Image(ct.GetSize(), sitk.sitkUInt8); grow_union.CopyInformation(ct)

    for ep in ant_seeds:
        # Tier A: long, strict
        corA = corridor_for_tip(rib, spine, ep, A_R_RIB_MM, A_R_TIP_MM, ct)
        gA   = region_grow_local(ct, [ep], a_lower, UPPER_HU, corA)
        gA   = keep_growth_touching_rib(gA, rib)
        gA   = thicken_growth_in_corridor(ct, gA, corA, a_lower, UPPER_HU)

        # Tier B: short, permissive (rounding)
        corB = corridor_for_tip(rib, spine, ep, B_R_RIB_MM, B_R_TIP_MM, ct)
        gB   = region_grow_local(ct, [ep], b_lower, UPPER_HU, corB)
        gB   = keep_growth_touching_rib(gB, rib)
        gB   = thicken_growth_in_corridor(ct, gB, corB, b_lower, UPPER_HU)

        grow_union = sitk.Or(grow_union, sitk.Or(gA, gB))

    pre = sitk.Or(rib, grow_union)

    # Refine (small, anisotropic closing) and write single output
    refined = sitk.BinaryMorphologicalClosing(pre, FINAL_CLOSING)
    write_img(refined, out_path)
    print(f"[OK] saved â†’ {out_path}")

# -------------------- file matching (only rib_left_1 / rib_right_1) --------------------
STEM_RE = re.compile(r'^rib[-_](left|right)[-_]0?1$', re.I)

def stem_no_ext(filename: str) -> str:
    f = filename.lower()
    if f.endswith(".nii.gz"): return f[:-7]
    if f.endswith(".nii"):    return f[:-4]
    return f

def list_first_ribs(ribs_dir: str):
    hits = []
    for root, _, files in os.walk(ribs_dir):
        for f in files:
            lf = f.lower()
            if not (lf.endswith(".nii") or lf.endswith(".nii.gz")):
                continue
            if STEM_RE.match(stem_no_ext(lf)):
                hits.append(os.path.join(root, f))
    return hits

# -------------------------- Driver ---------------------------
if __name__ == "__main__":
    base_dir = "/Users/chensirong/TotalSegmentator_postprocessing"
    totalSegmentator_data = os.path.join(base_dir, "TotalSegmentator_Data")

    # SINGLE output directory
    out_dir  = os.path.join(base_dir, "postprocessed_output")
    os.makedirs(out_dir, exist_ok=True)

    SUBJECT_PREFIXES = ("CF", "CM")
    subjects = sorted([
    d for d in os.listdir(totalSegmentator_data)
    if os.path.isdir(os.path.join(totalSegmentator_data, d))
    and d.upper().startswith(SUBJECT_PREFIXES)
    ])

    for subj in subjects:
        print(f"\n===== Processing subject: {subj} =====")
        subj_dir = os.path.join(totalSegmentator_data, subj)
        ct_path  = os.path.join(subj_dir, f"{subj}_resampled.nii.gz")
        ribs_dir = os.path.join(subj_dir, f"{subj}_test")

        if not os.path.exists(ct_path):
            print(f"[WARNING] Missing CT for {subj}, skipping.")
            continue
        if not os.path.isdir(ribs_dir):
            print(f"[WARNING] {ribs_dir} not found; skipping {subj}.")
            continue

        rib_files = list_first_ribs(ribs_dir)
        if not rib_files:
            print(f"[WARNING] No rib_left_1 / rib_right_1 in {ribs_dir}; skipping {subj}.")
            continue
        else:
            print(f"[INFO] Found ribs: {[os.path.basename(p) for p in rib_files]}")

        # read CT once
        ct = to_f32(read_img(ct_path))

        for rib_path in sorted(rib_files):
            base = os.path.basename(rib_path).replace(".nii.gz", "").replace(".nii", "")
            out_path = os.path.join(out_dir, f"{subj}_{base}_postprocessed.nii.gz")
            try:
                repair_first_rib(ct, rib_path, out_path)
            except Exception as e:
                print(f"[ERROR] {subj}/{base}: {e}")

    print("\nðŸŽ‰ All subjects processed!")